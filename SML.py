# -*- coding: utf-8 -*-
"""Untitled26.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ARlRPn9aKXLZGrIH7CNv9ji8FxFP3tj3
"""



import yfinance as yf
import pandas as pd
import numpy as np
import plotly.express as px
from sklearn.linear_model import LinearRegression

# Define tickers
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META']
market_ticker = '^GSPC'  # S&P 500 as market proxy

# Fetch adjusted close prices
start_date = '2020-01-01'
end_date = '2025-01-01'

data = yf.download(tickers + [market_ticker], start=start_date, end=end_date)

# Select only the 'Close' price columns for all tickers and the market
close_prices = data['Close']

returns = close_prices.pct_change().dropna()
annual_returns = returns.resample('Y').apply(lambda x: (x + 1).prod() - 1)

# Calculate HPR and HPY
hpr = annual_returns + 1
hpy = hpr - 1

# Risk Metrics
arithmetic_mean = annual_returns.mean()
geometric_mean = hpr.prod()**(1/len(hpr)) - 1
variance = annual_returns.var()
std_dev = annual_returns.std()
coeff_var = std_dev / arithmetic_mean


# Expected Return Modeling
# Print columns to inspect the structure
print(annual_returns.columns)

X = annual_returns[[market_ticker]]
expected_returns = {}
betas = {}

for ticker in tickers:
    y = annual_returns[[ticker]]
    model = LinearRegression().fit(X, y)
    beta = model.coef_[0][0]
    alpha = model.intercept_[0]
    expected_return = alpha + beta * X.mean().values[0]
    expected_returns[ticker] = expected_return
    betas[ticker] = beta

# Create DataFrame for Plotly
sml_df = pd.DataFrame({
    'Ticker': tickers,
    'Beta': [betas[t] for t in tickers],
    'Expected Return': [expected_returns[t] for t in tickers]
})

# Interactive SML Plot
fig = px.scatter(sml_df, x='Beta', y='Expected Return', text='Ticker',
                 title='Security Market Line (Interactive)',
                 labels={'Beta': 'Beta', 'Expected Return': 'Expected Return'},
                 template='plotly_white')
fig.update_traces(marker=dict(size=12), textposition='top center')
fig.show()

print("Arithmetic Mean Annual Returns:")
display(arithmetic_mean)

print("\nGeometric Mean Annual Returns:")
display(geometric_mean)

print("\nVariance of Annual Returns:")
display(variance)

print("\nStandard Deviation of Annual Returns (Risk):")
display(std_dev)

print("\nCoefficient of Variation (Risk per Unit of Return):")
display(coeff_var)

risk_free_ticker = '^TNX' # 10-year Treasury yield as risk-free rate proxy
risk_free_data = yf.download(risk_free_ticker, start=start_date, end=end_date)

risk_free_rate_close = risk_free_data['Close']
average_risk_free_rate = risk_free_rate_close.mean() / 100

import plotly.graph_objects as go

expected_returns = {}
betas = {}

# Extract the scalar value from the average_risk_free_rate Series
rf_rate_scalar = average_risk_free_rate.iloc[0]

# Print columns to inspect the structure
print(annual_returns.columns)

X = annual_returns[[market_ticker]]
expected_returns = {}
betas = {}

for ticker in tickers:
    y = annual_returns[[ticker]]
    model = LinearRegression().fit(X, y)
    beta = model.coef_[0][0]
    alpha = model.intercept_[0]
    # CAPM formula: expected_return = risk_free_rate + beta * (market_return - risk_free_rate)
    expected_return = rf_rate_scalar + beta * (X.mean().values[0] - rf_rate_scalar)
    expected_returns[ticker] = expected_return
    betas[ticker] = beta

# Create DataFrame for Plotly
sml_df = pd.DataFrame({
    'Ticker': tickers,
    'Beta': [betas[t] for t in tickers],
    'Expected Return': [expected_returns[t] for t in tickers]
})

# Interactive SML Plot
fig = px.scatter(sml_df, x='Beta', y='Expected Return', text='Ticker',
                 title='Security Market Line (Interactive) with CAPM',
                 labels={'Beta': 'Beta', 'Expected Return': 'Expected Return'},
                 template='plotly_white')

# Add the Security Market Line
min_beta = sml_df['Beta'].min()
max_beta = sml_df['Beta'].max()
sml_x = np.array([min_beta, max_beta])
sml_y = rf_rate_scalar + sml_x * (X.mean().values[0] - rf_rate_scalar)

fig.add_trace(go.Scattergl(x=sml_x, y=sml_y, mode='lines', name='SML',
                          line=dict(color='red', width=2)))

fig.update_traces(marker=dict(size=12), textposition='top center')
fig.show()

import plotly.graph_objects as go

expected_returns = {}
betas = {}

# Extract the scalar value from the average_risk_free_rate Series
rf_rate_scalar = average_risk_free_rate.iloc[0]

for ticker in tickers:
    y = annual_returns[[ticker]]
    model = LinearRegression().fit(X, y)
    beta = model.coef_[0][0]
    alpha = model.intercept_[0]
    # CAPM formula: expected_return = risk_free_rate + beta * (market_return - risk_free_rate)
    expected_return = rf_rate_scalar + beta * (X.mean().values[0] - rf_rate_scalar)
    expected_returns[ticker] = expected_return
    betas[ticker] = beta

# Create DataFrame for Plotly
sml_df = pd.DataFrame({
    'Ticker': tickers,
    'Beta': [betas[t] for t in tickers],
    'Expected Return': [expected_returns[t] for t in tickers]
})

# Interactive SML Plot
fig = px.scatter(sml_df, x='Beta', y='Expected Return', text='Ticker',
                 title='Security Market Line (Interactive) with CAPM',
                 labels={'Beta': 'Beta', 'Expected Return': 'Expected Return'},
                 template='plotly_white')

# Add the Security Market Line
min_beta = sml_df['Beta'].min()
max_beta = sml_df['Beta'].max()
sml_x = np.array([min_beta, max_beta])
sml_y = rf_rate_scalar + sml_x * (X.mean().values[0] - rf_rate_scalar)


fig.add_trace(go.Scattergl(x=sml_x, y=sml_y, mode='lines', name='SML',
                          line=dict(color='red', width=2)))

fig.update_traces(marker=dict(size=12), textposition='top center')
fig.show()



risk_free_row = pd.DataFrame({
    'Ticker': ['Risk-Free'],
    'Beta': [0],
    'Expected Return': [rf_rate_scalar]
})

sml_df = pd.concat([sml_df, risk_free_row], ignore_index=True)

# Interactive SML Plot with Risk-Free Asset
fig = px.scatter(sml_df, x='Beta', y='Expected Return', text='Ticker',
                 title='Security Market Line (Interactive) with CAPM and Risk-Free Asset',
                 labels={'Beta': 'Beta', 'Expected Return': 'Expected Return'},
                 template='plotly_white')

# Add the Security Market Line
min_beta = sml_df['Beta'].min()
max_beta = sml_df['Beta'].max()
sml_x = np.array([min_beta, max_beta])
sml_y = rf_rate_scalar + sml_x * (X.mean().values[0] - rf_rate_scalar)

fig.add_trace(go.Scattergl(x=sml_x, y=sml_y, mode='lines', name='SML',
                          line=dict(color='red', width=2)))

fig.update_traces(marker=dict(size=12), textposition='top center')
fig.show()

import plotly.graph_objects as go

# Calculate average actual annual returns
average_actual_returns = annual_returns[tickers].mean()

# Interactive SML Plot with CAPM, Risk-Free Asset, and Actual Returns
fig = px.scatter(sml_df, x='Beta', y='Expected Return', text='Ticker',
                 title='Security Market Line (Interactive) with CAPM, Risk-Free Asset, and Actual Returns',
                 labels={'Beta': 'Beta', 'Expected Return': 'Expected Return'},
                 template='plotly_white')

# Add the Security Market Line
min_beta = sml_df['Beta'].min()
max_beta = sml_df['Beta'].max()
sml_x = np.array([min_beta, max_beta])
sml_y = rf_rate_scalar + sml_x * (X.mean().values[0] - rf_rate_scalar)

fig.add_trace(go.Scattergl(x=sml_x, y=sml_y, mode='lines', name='SML',
                          line=dict(color='red', width=2)))

# Add actual annual returns
fig.add_trace(go.Scattergl(x=[betas[t] for t in tickers],
                          y=[average_actual_returns[t] for t in tickers],
                          mode='markers',
                          name='Actual Annual Return',
                          marker=dict(color='green', size=12, symbol='square'),
                          text=tickers,
                          textposition='bottom center'))


fig.update_traces(marker=dict(size=12), textposition='top center')
fig.show()